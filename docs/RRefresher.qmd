---
title: "R Refresher"
author: "adapted from Weisberg ALR (2014)"
format:
  html:
    code-fold: true
    toc: true
engine: knitr
filters:
  - webr
webr:
  show-startup-message: false    
packages: ['ggplot2', 'knitr', 'dplyr','tidyr']
---
This is an R Refresher adapted from Weisberg (2014)
We will use packages ggplot2, knitr, dplyr and tidyr

```{webr-r}
webr::install("ggplot2")
webr::install("knitr")
webr::install("dplyr")
webr::install("tidyr")
library(ggplot2)
library(knitr)
library(dplyr)
library(tidyr)
```

# Built in data

Upon loading library dplyr we will have access to the built-in dataset named "starwars".  Whenever one has been given a dataset, take a closer look to better understand it:

## dim()

```{webr-r}
dim(starwars)
```

## head()

```{webr-r}
head(starwars)
```

## summary()

```{webr-r}
summary(starwars[, c(1:3,7)])
```

Summary is being abused here.  While it is fast and gives us the count of NA (missing), do consider that rounding error could occur for the summary statistics.  Functions for computing stats like mean( ) can be found elsewhere:

## descriptive basics

Challenge (and working with webR), in teams, please compute the following for the variable **birth_year** in the starwars data:

  + mean, 
  + sd, 
  + five number summary, 
  + deciles, 
  + the number of missing values
  + and a count (number) of unique birth years

```{webr-r}
# please write you code here, run it, and upload copy of your code
# on BruinLearn before 11:59pm tonight for credit

```

## conditioning/grouping

We will use more of this later in the course, but for now, you should possess these fundamental data handling skills:

### in base R

We could use some basic character manipulation to make the result a little more compact. Here's the issue:

```{webr-r}
table(starwars$hair_color, useNA = "always")
```

The variable hair_color is a little too granular, let's propose a simple fix, just keep first mention of hair color:

```{webr-r}
# using base R only 
starwars$hair_color_first <- sapply(strsplit(as.character(starwars$hair_color), ","), 
                                    function(x) x[1])
# check it
table(starwars$hair_color_first, useNA = "always")
```

Now let's examine mass (weight) by hair_color and gender in base R:

```{webr-r}
tapply(starwars$mass, list(starwars$hair_color_first, starwars$gender), mean, na.rm = TRUE)
```

### using dplyr with a little tidyr

This is a preferred alternative to the base R solution because (1) it has more options and (2) you don't lose as much information. First some data preparation, similar to the base R solution

```{webr-r}
starwars <- starwars %>% # pipe in tidyverse
  mutate(hair_color_1_dplyr = sapply(strsplit(as.character(hair_color), ","), function(x) x[1]))

# check it
table(starwars$hair_color_1_dplyr, useNA = "always")
```

If we were to stop after the summarize() below we would have a "long"/"tall" result suitable for data visualization and other functions, but it's a little difficult to make comparisons as tabled results:

```{webr-r}
starwars %>%
  group_by(hair_color_1_dplyr, gender) %>%
  summarize(mean_mass = mean(mass, na.rm = TRUE))
```

By using .groups = "drop" and a pivot_wider() (from tidyr) we arrive at a comparable outcome, notice the missing categories:

```{webr-r}
starwars %>%
  group_by(hair_color_1_dplyr, gender) %>%
  summarize(mean_mass = mean(mass, na.rm = TRUE), .groups = "drop") %>% 
  pivot_wider(names_from = gender, values_from = mean_mass)
```

We will delve into more data handling in the future.

# Data External to R

## locally

This is the general format for reading data in base R (won't run on this website, you'll need to try it in R on your own computer)

```
my_data0 <- read.table("filename", header=TRUE,
na.strings="NA", sep = "")
```

There are modifications to this basic code, for example, read.csv() is just a alias of read.table() with sep = "," as a default.  We can use it in concert with file.choose() to allow you to select files from your local drive (won't work here, just an example)

```
my_data1 <- read.csv(file.choose(), header=TRUE,
na.strings="NA")
```

## remotely
We can also read data from a website, note the use of read.table() with sep = ",":

```{webr-r}
my_data2 <-read.table("https://raw.githubusercontent.com/lewv/S24STATS101A/main/data/holten.csv",
               header=TRUE, sep=",")
```

Another good first step involves examining the structure of the object:

```{webr-r}
str(my_data2)
```

This will help identify numeric and non-numeric data.  

We could load an additional package, readr, to allow us to read additional data formats such as Excel files (this is something you can do in section or in an assignment)

# Distributions

It's important to know how to use the functions associated with distributions in R as many advanced textbooks do not have t-tables etc.    
The first letters of each distribution family function have the following meaning:

r - random generation, given a number of observations  
p - distribution function, given a quantile  
q - quantile function, given a probability  
d - density, given a quantile  

## Examples

### normal
The normal distribution's root is "norm". The function  pnorm() takes a quantile and returns a probability of observing a value less than or equal to 1.96 in a standard normal distribution:

```{webr-r}
pnorm(1.96)
```

We can change the pnorm defaults to accommodate a different situation, here, SAT scores combined math/verbal: 

```{webr-r}
pnorm(1405, mean = 1000, sd = 200) #UCLA
pnorm(1505, mean = 1000, sd = 200) #Stanford
pnorm(1135, mean = 1000, sd = 200) #UNLV
```

qnorm() answers the question - given a probability what is the value of the associated quantile?

```{webr-r}
qnorm(0.975, mean = 0, sd = 1)
qnorm(0.025, mean = 0, sd = 1)
qnorm(0.95, mean = 1000, sd = 200)
```

dnorm() - returns the height of the probability density function at  points specified by the programmer. In the normal distribution, points farther from the mean have lower density

```{webr-r}
dnorm(c(-2, -1, 0, 1, 2), mean = 0, sd = 1)
```

### t

There are other distributions with different root names, but the same four letter identifier holds

```{webr-r}
pt(1.96, df = 10)
pt(1.96, df = 100)
pt(1.96, df = 1000)
```

```{webr-r}
qt(0.025, df = 10)
qt(0.975, df = 10)
```

### chi-square

```{webr-r}
pchisq(q = 3.84, df = 1)
qchisq(0.95, df = 1)
```

an additional density example and our bridge to visualization

```{webr-r}
x <- seq(from = 0, to = 10, by = 0.1)

plot(x, dchisq(x, df = 1), type = "l", 
     main = "Chi-Square Distribution with 1 Degree of Freedom",
     xlab = "Value", ylab = "Density", col = "red")
```

### Test yourself/your team

Please try generating values from another distribution (e.g., F, Poisson), you can find a longer list of distributions here: https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Distributions.html

```{webr-r}
## Please try plotting or generating some values from a distribution you haven't seen demonstrated today (so no normal, t or chi-square)



```

# Visualizing Data

## saving graphics
We can output graphics by using the GUI or directly in our code (will only run locally):

```
pdf("myhist.pdf", height=5, width=5)
hist(rnorm(100))
dev.off()
```

## plot() in base R

Base R's plot() function is a reasonable starting point and convenient:

```{webr-r}
plot(iris$Sepal.Width ~ iris$Sepal.Length, 
     col = iris$Species, pch = 20, 
     main = "Sepal Width on Sepal Length",
     ylab = "Sepal Width",
     xlab = "Sepal Length")
```

## ggplot( )

We have more data visualization power with ggplot.  We could add straight lines (AKA fit linear models) for each species and for overall

```{webr-r}
ggplot(iris, aes(x = Sepal.Length, 
                 y = Sepal.Width,
                 color = Species)) +
  geom_point() + 
  geom_smooth(method = 'lm', se = FALSE) +
  geom_smooth(method = 'lm', se = FALSE, color = "black", aes(linetype = "Overall")) +  # Black line for overall trend
  scale_color_manual(values = c("setosa" = "red", "versicolor" = "green", "virginica" = "blue")) +
  scale_linetype_manual(name = "", values = c("Overall" = "solid"), labels = "Overall Trend") +
  guides(color = guide_legend(title = "By Species")) +
  theme_minimal()
```

## plot() within a for loop
Another example, first using base R to plot 4 graphs in a single window:

```{webr-r}
.pardefault <- par(no.readonly = TRUE)  # save defaults
par(mfrow=c(2, 2)) # change to 2 by 2
xs <- names(anscombe)[1:4]
ys <- names(anscombe)[5:8]
for (i in 1:4){
  plot(anscombe[, xs[i]], anscombe[, ys[i]], xlab=xs[i], ylab=ys[i],
       xlim=c(4,20), ylim=c(2, 16))
  abline(lm( anscombe[, ys[i]] ~ anscombe[, xs[i]]))
}
par(.pardefault) # restore
```

## Tidyverse style

We can do the same with ggplot, but it requires more data handling

First, pivot the data from wide to long/tall:

```{webr-r}
head(anscombe)
```

```{webr-r}
anscombe_long <- anscombe %>% 
  pivot_longer(cols = everything(),
               names_to = c(".value", "set"),
               names_pattern = "(.)(.)")
```

Always check your results:

```{webr-r}
head(anscombe_long)
```

ggplot will be much happier with "long" (AKA "tall" maybe also "stacked")

```{webr-r}
ggplot(anscombe_long, aes(x = x, y = y, color = set)) +
  geom_point() +
  facet_wrap(~ set) +
  labs(title = "Anscombe's Quartet",
       x = "X value",
       y = "Y value") +
  theme_minimal() +
  theme(legend.position = "none")
```

We can calculate the correlations for each set, the group_by() function combined with summarize in dplyr is very useful for that.

```{webr-r}
correlations <- anscombe_long %>% 
  group_by(set) %>% 
  summarize(correlation = cor(x, y))
print(correlations)
```

## Five minute ggplot refresher

If there is only one package you need in R, it's ggplot.  It's simple and logical and flows with data beautifully.  We can use penguins

```{webr-r}
penguins <- read.csv("https://gist.githubusercontent.com/slopp/ce3b90b9168f2f921784de84fa445651/raw/4ecf3041f0ed4913e7c230758733948bc561f434/penguins.csv")
str(penguins)
```

ggplot needs to know what data you plan to use and it needs to have an aesthetic (aes) specified.  

```{webr-r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species))
```

No error, but no graphic.  All we have done is specified the data and given ggplot a sense of how the graphic should appear (x, y, color) as it relates to the features.  

The "+" separates "layers".  Think of ggplot as like making a cake, you lay down the foundation and then you start decorating.  Next up, the geom_ which tell ggplot how the features should be plotted.

```{webr-r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +
  geom_point() 
```

That is just about it.  I do recommend you learn how to "facet" (condition) the plots:

```{webr-r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +
  geom_point() +
  facet_wrap(~ island)
```

read "as a function of island", if you wanted island on the rows, move to facet_grid()

```{webr-r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +
  geom_point() +
  facet_grid(rows = vars(island))
```

a better use of facet_grid

```{webr-r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +
  geom_point() +
  facet_grid(sex ~ island)
```

The remaining functions deal with appearance such as labels, legends and maybe adding additional geoms:

```{webr-r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +
  geom_point() +
  geom_smooth() +
  labs(title = "Palmer Penguin Populations",
       x = "Flipper Length (mm)",
       y = "Body Mass (g)") +
  theme_classic()
```