{
  "hash": "ce42800db922c50448030bf3119f349b",
  "result": {
    "markdown": "---\ntitle: \"R Refresher\"\nauthor: \"adapted from Weisberg ALR (2014)\"\nformat:\n  html:\n    code-fold: true\n    toc: true\nengine: knitr\nfilters:\n  - webr\nwebr:\n  show-startup-message: false    \npackages: ['ggplot2', 'knitr', 'dplyr','tidyr']\n---\n\nThis is an R Refresher adapted from Weisberg (2014)\nWe will use packages ggplot2, knitr, dplyr and tidyr\n\n```{webr-r}\nwebr::install(\"ggplot2\")\nwebr::install(\"knitr\")\nwebr::install(\"dplyr\")\nwebr::install(\"tidyr\")\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(dplyr)\nlibrary(tidyr)\n```\n\n# Built in data\n\nUpon loading library dplyr we will have access to the built-in dataset named \"starwars\".  Whenever one has been given a dataset, take a closer look to better understand it:\n\n## dim()\n\n```{webr-r}\ndim(starwars)\n```\n\n## head()\n\n```{webr-r}\nhead(starwars)\n```\n\n## summary()\n\n```{webr-r}\nsummary(starwars[, c(1:3,7)])\n```\n\nSummary is being abused here.  While it is fast and gives us the count of NA (missing), do consider that rounding error could occur for the summary statistics.  Functions for computing stats like mean( ) can be found elsewhere:\n\n## descriptive basics\n\nChallenge (and working with webR), in teams, please compute the following for the variable **birth_year** in the starwars data:\n\n  + mean, \n  + sd, \n  + five number summary, \n  + deciles, \n  + the number of missing values\n  + and a count (number) of unique birth years\n\n```{webr-r}\n# please write you code here, run it, and upload copy of your code\n# on BruinLearn before 11:59pm tonight for credit\n\n```\n\n## conditioning/grouping\n\nWe will use more of this later in the course, but for now, you should possess these fundamental data handling skills:\n\n### in base R\n\nWe could use some basic character manipulation to make the result a little more compact. Here's the issue:\n\n```{webr-r}\ntable(starwars$hair_color, useNA = \"always\")\n```\n\nThe variable hair_color is a little too granular, let's propose a simple fix, just keep first mention of hair color:\n\n```{webr-r}\n# using base R only \nstarwars$hair_color_first <- sapply(strsplit(as.character(starwars$hair_color), \",\"), \n                                    function(x) x[1])\n# check it\ntable(starwars$hair_color_first, useNA = \"always\")\n```\n\nNow let's examine mass (weight) by hair_color and gender in base R:\n\n```{webr-r}\ntapply(starwars$mass, list(starwars$hair_color_first, starwars$gender), mean, na.rm = TRUE)\n```\n\n### using dplyr with a little tidyr\n\nThis is a preferred alternative to the base R solution because (1) it has more options and (2) you don't lose as much information. First some data preparation, similar to the base R solution\n\n```{webr-r}\nstarwars <- starwars %>% # pipe in tidyverse\n  mutate(hair_color_1_dplyr = sapply(strsplit(as.character(hair_color), \",\"), function(x) x[1]))\n\n# check it\ntable(starwars$hair_color_1_dplyr, useNA = \"always\")\n```\n\nIf we were to stop after the summarize() below we would have a \"long\"/\"tall\" result suitable for data visualization and other functions, but it's a little difficult to make comparisons as tabled results:\n\n```{webr-r}\nstarwars %>%\n  group_by(hair_color_1_dplyr, gender) %>%\n  summarize(mean_mass = mean(mass, na.rm = TRUE))\n```\n\nBy using .groups = \"drop\" and a pivot_wider() (from tidyr) we arrive at a comparable outcome, notice the missing categories:\n\n```{webr-r}\nstarwars %>%\n  group_by(hair_color_1_dplyr, gender) %>%\n  summarize(mean_mass = mean(mass, na.rm = TRUE), .groups = \"drop\") %>% \n  pivot_wider(names_from = gender, values_from = mean_mass)\n```\n\nWe will delve into more data handling in the future.\n\n# Data External to R\n\n## locally\n\nThis is the general format for reading data in base R (won't run on this website, you'll need to try it in R on your own computer)\n\n```\nmy_data0 <- read.table(\"filename\", header=TRUE,\nna.strings=\"NA\", sep = \"\")\n```\n\nThere are modifications to this basic code, for example, read.csv() is just a alias of read.table() with sep = \",\" as a default.  We can use it in concert with file.choose() to allow you to select files from your local drive (won't work here, just an example)\n\n```\nmy_data1 <- read.csv(file.choose(), header=TRUE,\nna.strings=\"NA\")\n```\n\n## remotely\nWe can also read data from a website, note the use of read.table() with sep = \",\":\n\n```{webr-r}\nmy_data2 <-read.table(\"https://raw.githubusercontent.com/lewv/S24STATS101A/main/data/holten.csv\",\n               header=TRUE, sep=\",\")\n```\n\nAnother good first step involves examining the structure of the object:\n\n```{webr-r}\nstr(my_data2)\n```\n\nThis will help identify numeric and non-numeric data.  \n\nWe could load an additional package, readr, to allow us to read additional data formats such as Excel files (this is something you can do in section or in an assignment)\n\n# Distributions\n\nIt's important to know how to use the functions associated with distributions in R as many advanced textbooks do not have t-tables etc.    \nThe first letters of each distribution family function have the following meaning:\n\nr - random generation, given a number of observations  \np - distribution function, given a quantile  \nq - quantile function, given a probability  \nd - density, given a quantile  \n\n## Examples\n\n### normal\nThe normal distribution's root is \"norm\". The function  pnorm() takes a quantile and returns a probability of observing a value less than or equal to 1.96 in a standard normal distribution:\n\n```{webr-r}\npnorm(1.96)\n```\n\nWe can change the pnorm defaults to accommodate a different situation, here, SAT scores combined math/verbal: \n\n```{webr-r}\npnorm(1405, mean = 1000, sd = 200) #UCLA\npnorm(1505, mean = 1000, sd = 200) #Stanford\npnorm(1135, mean = 1000, sd = 200) #UNLV\n```\n\nqnorm() answers the question - given a probability what is the value of the associated quantile?\n\n```{webr-r}\nqnorm(0.975, mean = 0, sd = 1)\nqnorm(0.025, mean = 0, sd = 1)\nqnorm(0.95, mean = 1000, sd = 200)\n```\n\ndnorm() - returns the height of the probability density function at  points specified by the programmer. In the normal distribution, points farther from the mean have lower density\n\n```{webr-r}\ndnorm(c(-2, -1, 0, 1, 2), mean = 0, sd = 1)\n```\n\n### t\n\nThere are other distributions with different root names, but the same four letter identifier holds\n\n```{webr-r}\npt(1.96, df = 10)\npt(1.96, df = 100)\npt(1.96, df = 1000)\n```\n\n```{webr-r}\nqt(0.025, df = 10)\nqt(0.975, df = 10)\n```\n\n### chi-square\n\n```{webr-r}\npchisq(q = 3.84, df = 1)\nqchisq(0.95, df = 1)\n```\n\nan additional density example and our bridge to visualization\n\n```{webr-r}\nx <- seq(from = 0, to = 10, by = 0.1)\n\nplot(x, dchisq(x, df = 1), type = \"l\", \n     main = \"Chi-Square Distribution with 1 Degree of Freedom\",\n     xlab = \"Value\", ylab = \"Density\", col = \"red\")\n```\n\n### Test yourself/your team\n\nPlease try generating values from another distribution (e.g., F, Poisson), you can find a longer list of distributions here: https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Distributions.html\n\n```{webr-r}\n## Please try plotting or generating some values from a distribution you haven't seen demonstrated today (so no normal, t or chi-square)\n\n\n\n```\n\n# Visualizing Data\n\n## saving graphics\nWe can output graphics by using the GUI or directly in our code (will only run locally):\n\n```\npdf(\"myhist.pdf\", height=5, width=5)\nhist(rnorm(100))\ndev.off()\n```\n\n## plot() in base R\n\nBase R's plot() function is a reasonable starting point and convenient:\n\n```{webr-r}\nplot(iris$Sepal.Width ~ iris$Sepal.Length, \n     col = iris$Species, pch = 20, \n     main = \"Sepal Width on Sepal Length\",\n     ylab = \"Sepal Width\",\n     xlab = \"Sepal Length\")\n```\n\n## ggplot( )\n\nWe have more data visualization power with ggplot.  We could add straight lines (AKA fit linear models) for each species and for overall\n\n```{webr-r}\nggplot(iris, aes(x = Sepal.Length, \n                 y = Sepal.Width,\n                 color = Species)) +\n  geom_point() + \n  geom_smooth(method = 'lm', se = FALSE) +\n  geom_smooth(method = 'lm', se = FALSE, color = \"black\", aes(linetype = \"Overall\")) +  # Black line for overall trend\n  scale_color_manual(values = c(\"setosa\" = \"red\", \"versicolor\" = \"green\", \"virginica\" = \"blue\")) +\n  scale_linetype_manual(name = \"\", values = c(\"Overall\" = \"solid\"), labels = \"Overall Trend\") +\n  guides(color = guide_legend(title = \"By Species\")) +\n  theme_minimal()\n```\n\n## plot() within a for loop\nAnother example, first using base R to plot 4 graphs in a single window:\n\n```{webr-r}\n.pardefault <- par(no.readonly = TRUE)  # save defaults\npar(mfrow=c(2, 2)) # change to 2 by 2\nxs <- names(anscombe)[1:4]\nys <- names(anscombe)[5:8]\nfor (i in 1:4){\n  plot(anscombe[, xs[i]], anscombe[, ys[i]], xlab=xs[i], ylab=ys[i],\n       xlim=c(4,20), ylim=c(2, 16))\n  abline(lm( anscombe[, ys[i]] ~ anscombe[, xs[i]]))\n}\npar(.pardefault) # restore\n```\n\n## Tidyverse style\n\nWe can do the same with ggplot, but it requires more data handling\n\nFirst, pivot the data from wide to long/tall:\n\n```{webr-r}\nhead(anscombe)\n```\n\n```{webr-r}\nanscombe_long <- anscombe %>% \n  pivot_longer(cols = everything(),\n               names_to = c(\".value\", \"set\"),\n               names_pattern = \"(.)(.)\")\n```\n\nAlways check your results:\n\n```{webr-r}\nhead(anscombe_long)\n```\n\nggplot will be much happier with \"long\" (AKA \"tall\" maybe also \"stacked\")\n\n```{webr-r}\nggplot(anscombe_long, aes(x = x, y = y, color = set)) +\n  geom_point() +\n  facet_wrap(~ set) +\n  labs(title = \"Anscombe's Quartet\",\n       x = \"X value\",\n       y = \"Y value\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n\nWe can calculate the correlations for each set, the group_by() function combined with summarize in dplyr is very useful for that.\n\n```{webr-r}\ncorrelations <- anscombe_long %>% \n  group_by(set) %>% \n  summarize(correlation = cor(x, y))\nprint(correlations)\n```\n\n## Five minute ggplot refresher\n\nIf there is only one package you need in R, it's ggplot.  It's simple and logical and flows with data beautifully.  We can use penguins\n\n```{webr-r}\npenguins <- read.csv(\"https://gist.githubusercontent.com/slopp/ce3b90b9168f2f921784de84fa445651/raw/4ecf3041f0ed4913e7c230758733948bc561f434/penguins.csv\")\nstr(penguins)\n```\n\nggplot needs to know what data you plan to use and it needs to have an aesthetic (aes) specified.  \n\n```{webr-r}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species))\n```\n\nNo error, but no graphic.  All we have done is specified the data and given ggplot a sense of how the graphic should appear (x, y, color) as it relates to the features.  \n\nThe \"+\" separates \"layers\".  Think of ggplot as like making a cake, you lay down the foundation and then you start decorating.  Next up, the geom_ which tell ggplot how the features should be plotted.\n\n```{webr-r}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() \n```\n\nThat is just about it.  I do recommend you learn how to \"facet\" (condition) the plots:\n\n```{webr-r}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  facet_wrap(~ island)\n```\n\nread \"as a function of island\", if you wanted island on the rows, move to facet_grid()\n\n```{webr-r}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  facet_grid(rows = vars(island))\n```\n\na better use of facet_grid\n\n```{webr-r}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  facet_grid(sex ~ island)\n```\n\nThe remaining functions deal with appearance such as labels, legends and maybe adding additional geoms:\n\n```{webr-r}\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g, color = species)) +\n  geom_point() +\n  geom_smooth() +\n  labs(title = \"Palmer Penguin Populations\",\n       x = \"Flipper Length (mm)\",\n       y = \"Body Mass (g)\") +\n  theme_classic()\n```",
    "supporting": [
      "RRefresher_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}